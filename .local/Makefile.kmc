

# Pipeline:
# 1- generate a interleaved fastq if pair-end data
# 2- adapter and quality trimming with **fastp**
# 3- apply independently on REF and ALT
#    3.1- kmer counting on FWD and REV strands (with KMC)
#    3.2- intersect FWD and REV counts and keep min count (with KMC_TOOLS)
# 4- make union of kmers between REF and ALT (with KMC_TOOLS)
# 5- produce unitigs graph (or DBG, with BCALM2)
# 6- quantify kmer abundance of every unitigs using 3.2 (with kmc_abundance)
# 7- blast contigs to a reference gene database


KMER=51
#SHELL := bash

REF=data/fastq/1_S93_L002.interleaved.trim.fastq.gz
ALT=data/fastq/2_S94_L002.interleaved.trim.fastq.gz
ANN_FASTA_CDS=out/Kpn_HS11286_ann.fna
ANN_FASTA_GENOME=data/ref/Kpn_HS11286/GCF_000240185.1/GCF_000240185.1_ASM24018v2_genomic.fna
OUT_PREFIX=out/2vs1

# MAIN
all:$(OUT_PREFIX).kmc $(OUT_PREFIX).kmc.unitigs.gfa $(OUT_PREFIX).kmc.unitigs.fa $(OUT_PREFIX).kmc.unitigs.REF.csv $(OUT_PREFIX).kmc.unitigs.ALT.csv 
ann:$(OUT_PREFIX).kmc.unitigs.ann.blastn $(OUT_PREFIX).kmc.unitigs.ann.bam $(OUT_PREFIX).kmc.unitigs.ann.bam.bai $(OUT_PREFIX).kmc.unitigs.ann.vcf.bgz
report:$(OUT_PREFIX).report.html

$(OUT_PREFIX).kmc:$(REF:%.fastq.gz=%.kmc) $(ALT:%.fastq.gz=%.kmc)
	kmc_tools simple $(REF:%.fastq.gz=%) $(ALT:%.fastq.gz=%) union $(@:%.kmc=%) > $@

$(OUT_PREFIX).kmc.unitigs.REF.csv:$(OUT_PREFIX).kmc.unitigs.gfa $(REF:%.fastq.gz=%.kmc) $(ALT:%.fastq.gz=%.kmc)
	kmc_abundance $(OUT_PREFIX).kmc.unitigs.fa $(REF:%.fastq.gz=%) > "$@"

$(OUT_PREFIX).kmc.unitigs.ALT.csv:$(OUT_PREFIX).kmc.unitigs.gfa $(REF:%.fastq.gz=%.kmc) $(ALT:%.fastq.gz=%.kmc)
	kmc_abundance $(OUT_PREFIX).kmc.unitigs.fa $(ALT:%.fastq.gz=%) > "$@"

$(OUT_PREFIX).report.html:src/kmer_varcall/kmer_varcall.Rmd $(OUT_PREFIX).kmc.unitigs.ALT.csv $(OUT_PREFIX).kmc.unitigs.REF.csv $(OUT_PREFIX).kmc.unitigs.fa $(OUT_PREFIX).kmc.unitigs.ann.blastn
	Rscript -e 'rmarkdown::render("src/kmer_varcall/kmer_varcall.Rmd",params=list(prefix="$(OUT_PREFIX)"),knit_root_dir="$(PWD)",output_dir="$(@D)",output_file="$(@F)")'



#-#-#-#-#-#-#-#
# Annotations
#-#-#-#-#-#-#-#
%.ann.blastn:%.fa;blastn -subject "$<" -query "$(ANN_FASTA_CDS)" -outfmt "6 std qlen slen" > $@
%.ann.bam:%.fa;minimap2 -cx asm5 -z1000000 -p 0.1 -Y --cs -a '$(ANN_FASTA_GENOME)' '$<' | samtools sort -o '$@' -
%.bam.bai:%.bam;samtools index '$<'
%.bwa.bam:%_R1.fastq.gz %_R2.fastq.gz;bwa mem -t '$(ANN_FASTA_GENOME)' $^ | samtools sort -o '$@' -


# Perform variant calling from mapping result
# Convert secondary alignments into primary alignment to call variants on both
# This is important because our reference sequences are redundant and we want 
# to map our assemblies to all of them
%.ann.vcf.bgz:%.ann.bam
	samtools view -h $< \
	| paftools.js sam2paf - \
	| sort -k6,6 -k8,8n \
	| sed s/tp:A:S/tp:A:P/ \
	| paftools.js call -f "$(ANN_FASTA_GENOME)" -s "$(notdir $*)" -l0 -L0 -q0 - \
	| bgzip > "$@"



#-#-#-#-#-#-#-#
# SEQTK rules
#-#-#-#-#-#-#-#
# Trim adapter and produce interleaved FASTQ
.PRECIOUS:%.interleaved.trim.fastq.gz
%.interleaved.trim.fastq.gz:%_R1.fastq.gz %_R2.fastq.gz
	 fastp \
	  --adapter_sequence CTGTCTCTTATACACATCTCCGAGCCCACGAGAC \
	  --adapter_sequence_r2 CTGTCTCTTATACACATCTGACGCTGCCGACGA \
	  --in1 $(word 1,$^) \
	  --in2 $(word 2,$^) \
	  --stdout | pigz > $@

# Convert FASTQ to FASTA
%.fwd.fasta.gz:%.fastq.gz
	seqtk seq -A $< | pigz > $@

# Convert FASTQ to FASTA and Reverse complement
%.rev.fasta.gz:%.fastq.gz
	seqtk seq -Ar $< | pigz > $@


#-#-#-#-#-#-#
# KMC rules
#-#-#-#-#-#-#
# Non-canonical kmer count of a given FASTA in RAM-only mode (-r) and exclude 
# the ones occuring less than 5 times
.PRECIOUS:%.kmc
%.kmc:%.fasta.gz
	kmc -k$(KMER) -fa -b -r -t5 -ci5 "$<" "$*" /tmp > "$@"

# Intersect FWD and REV kmer set (and consider min-count of both)
%.kmc:%.fwd.kmc %.rev.kmc
	kmc_tools simple "$*.fwd" "$*.rev" intersect "$*" > "$@"

%.kmc.hist:%.kmc
	kmc_tools transform $* histogram /dev/stdout -cx64

%.kmc.fasta.gz:%.kmc
	kmc_tools transform "$*" dump -s /dev/stdout | awk '{print ">" NR " n=" $$2;print $$1}' | pigz > "$@"


#-#-#-#-#-#-#
# Unitigs
#-#-#-#-#-#-#
%.unitigs.gfa %.unitigs.fa:%.fasta.gz
	bcalm -abundance-min 0 -kmer-size $(KMER) -in "$<" -out $* \
	&& convertToGFA.py "$*.unitigs.fa" "$*.unitigs.gfa" $(KMER)








